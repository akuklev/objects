Значения и Объекты
==================

В мире императивного программирования (и моделирования физической реальности) центральной абстракцией является идеализированный материальный объект. Скажем, изменяемая переменная, содержащая целочисленное значение. Это такой “ящик” где лежит число.

Математика и чисто-функциональные языки программирования оперируют не объектами, но значениями. Значениями в математическом, платоническом смысле, например целое число 2.

К объектам применимо понятие “тот же самый, один и тот же” (same). Так в двух разных ящиках могут лежать равные числа, но это не делает из одним и тем же ящиком — если в одном поменять значение, оно не поменяется в другом. Объекты могут возникать/порождаться и исчезать/поглощаться, к ним применимо понятие жизненного цикла (lifecycle). В зависимости от того, что и как именно мы моделируем, может оказаться что те или иные объекты возможно “всегда были” и/или “всегда будут”. Не смотря на то,
что у таких объектов как будто нет “жизненного цикла” (по меньшей мере невырожденного), к ним применима сама концепция “материального существования” в какой-то момент при каких-то условиях.

К значениям, напротив, применимо понятие “равный” (equal, identifiable), но не “то же”. Быть равнми — это свойство пары значений, равенство может быть доказано или опровергнуто. А вот быть одним и тем же объектом можно только по определению.

К значением также неприменимо понятие жизненного цикла, про них даже нельзя сказать что они “всегда были и будут” — они просто вообще вне времени, вне “материального существования”. Они — информация, отделённая от ностеля.

Строгие языки с поддержкой объектов: Пример на пробу
----------------------------------------------------

В чистом функциональном языке программирования все выражения выражают значения в математическом
смысле, все аргументы всех функций представляют собой значения, и сами функции естественно тоже
значения. “Функцию”, которая принимает в качестве аргументов ещё и объект(ы) уже можно назвать
функцией только в кавычках, т.к. она сама перестаёт быть значением в математическом смысле.
Давайте будем называть такие “функции” методами, и немедленно рассмотрим один такой метод:
```kotlin
fun main(args : List<String>, STDOUT : !(String ⊸ Unit)) {
  for(i in args) STDOUT(i ++ "\n")
}
```

Нет, это написано не на Скале. Это вымышленный чисто-функциональный язык программирования,
в который добавили строго-престрого типизированные first-class объекты. Метод `main` принимает
кроме значения `args` ещё и объект `STDOUT` с устрашающей сигнатурой `!(String ⊸ Unit)`, которую
мы сейчас разберём подробнее.

Базовый класс объектов — одноразовые (one-shot) request endpoints, их тип обозначается через
```
ReqT ⊸ RespT
```
где `ReqT` и `RespT` два каких-то типа значений, называемых “тип запроса” и “тип ответа”.
Объекту такого типа можно скормить значение типа `ReqT` и в ответ получишь значение типа
`RespT`.

Если некая процедура приняла аргумент `EP : ReqT ⊸ RespT`, то в каждой ветви своего выполнения
она может (и должна) вызвать EP ровно один раз, не больше и не меньше. У нас имеются три
модификатора типов объектов:
- `EP : ¿(ReqT ⊸ RespT)` означает что получатель не обязан пользоваться EP. Пользоваться больше
одного раза (в каждой ветви исполнения) всё ещё нельзя, но требование пользоваться не __меньше__
убирается.
- `EP : *(ReqT ⊸ RespT)` означает что EP параллельно-многоразовый endpoint, то есть им можно
пользоваться ноль или более раз в каждой ветви выполнения. Такая сигнатура подходит, например,
физическому генератору случайных чисел `RAND : *(Unit ⊸ Int32)`.
- `EP : !(ReqT ⊸ RespT)` означает что EP последовательно-многоразовый endpoint. Под капотом
это такой тип объектов `S`, для которого выполняется `S = ¿(ReqT ⊸ RespT ⊗ S)`. То есть это
необязательный к использованию endpoint, возвращающий при использовании не только значение
типа `RespT`, но ещё один endpoint идентичного типа на замену себе. Именно с этой сигнатурой
мы сталкнулись в методе `main` выше. Там поток `STDOUT` это последовательно-многоразовый
request endpoint, принимающий строки и возвращающий Unit.

Программы, интерактивность которых сводится к command-line interface могут рассматриваться
как методы сигнатуры
```kotlin
fun main(args : List<String>, TTY : !(String ⊸ String))
```

Sidenote: Как и в случае с последовательно-многоразовыми, параллельно-многоразовые эндпоинты можно
рассматривать как синтаксический сахар над более низкоуровневой конструкцией. Можно считать, что
это объекты сигнатуры `S`, снабженные структурой комоноида, то есть операциями `discard` (так
называемая ко-единица) и `duplicate` (так называемая ко-композиция), в отношении которых
выполняются аксиомы, двойственные обычным аксомам моноида.


Равенство одноразовых запросов
------------------------------

В мире объектов понятие равенства распадается на две модальности — равенство эффектов и равенство
результатов, которые мы будем обозначать через =e= и =r= соответственно. 

Мы говорим, что запрос `EP : ReqT ⊸ RespT` детерминирован, если будучи вызван с одинаковым
аргументом он всякий раз выдаёт одинаковые результаты, т.е.
`a = b` влечёт `EP(a) =r= EP(b)`.

Обратим внимание, что это равенство вообще говоря нерефлексивное, например `RAND =r= RAND` НЕ
выполняется. Также обратим внимание, что равенство результатов не влечёт равенства эффектов:
с точки зрения результатов любые два запроса, возвращающие Unit, равны, но с точки зрения
эффектов `STDOUT("Hello")` и `STDOUT("Goodbye")` очевидно разные.

Равенство эффектов напротив рефлексивное, но не влечёт равенства результатов. Равенство эффектов
может быть использована для выражения независимости (параллелизуемости) запросов. Так например
запись в независимые потоки вывода (например, `STDOUT` и `STDERR`) независима, что мы можем
выразить через `{STDOUT(x); STDERR(y)} =e= {STDERR(y); STDOUT(x)}`.

Независимость двух сервисов отсутствие коммуникации между ними, но не означает детерминированности.
Пусть например программа
```kotlin
fun main(args : List<String>, TTY1 : !(String ⊸ String),
                              TTY2 : !(String ⊸ String))
```
взаимодействует с двумя пользователями через интерфейсы `TTY1` и `TTY2` соответственно.
Независимость `TTY1` и `TTY2` обеспечена в точности если физически исключена возможность
коммуникации пользователей между запросами. Знание о независимости запросов влияет на возможность
из параллелизовывать и таким образом производительность программы.

Замкнутые объекты и изолированность
-----------------------------------

Изолированностью называется свойство запроса `EP : X ⊸ Y` не влиять на другие запросы и не быть
подверженным влиянию других запросов. Так например запись в лог (программное считывание из лога
мы постулируем невозможным) является примером изолированного запроса. Изолированность запроса
`EP` мы можем выразить следующим образом: Для любого другого `EP' : X' ⊸ Y'` и
любых `x : X`, `x' : X'` выполняется

```
{
  val a := EP(x)
  val b := EP'(x')
  return (a, b)
} =r= {
  val b := EP'(x')
  val a := EP(x)
  return (a, b)
}
```

Замкнутым объектом называется совокупность запросов, изолированных от любых внешних запросов,
но не друг от друга, а сами эти запросы назваются методами объекта.

Так например, мутабельная переменная типа `X` это изолированный объект, имеющий методы
```
set : X ⊸ Unit
get : Unit ⊸ X?
```
со следующими свойствами:
```
{set(x); set(x')} =e= {set(x')}
{set(x); get} =r= x
get =r= get
{get} =e= {}

```
То есть,
1) последовательность `set`ов эффективно эквивалентна последнему из них;
2) `get` возвращает то, что было `set`-нуто (в последний раз, см. свойство 1);
3) `get` детерминистский (кстати, `set` тоже, просто потому что возвращает `Unit`)
4) `get` не имеет эффектов

Из свойств 1-3 следует что `get` возвращает null на неинициализированной переменной и только на ней.

Такого рода описания порождают монаду Дейкстры (https://arxiv.org/abs/1903.01237), предоставляющую удобный инструмент reasoning'а в процедурах. Однако для более сложных случаев нужно разобраться как описывать незамкнутые подобъекты замкнутого объекта (sharing & ownership) так чтобы монада Дейкстры оснащалась полным инструментарием сепарационной логики.

Ещё нужно отметить, что могут быть объекты, имеющие всего один метод. Например уже упоминавшийся
`RAND`.

N.B. Незамкнутые объекты называем сервисами или агентами.

Когда объекты ведут себя как значения
-------------------------------------

Методами теории категорий можно показать, что с процедурой, использующей изолированные
детерминированные параллельно- или последовательно-многоразовые операции, можно обращаться в точностью
также как если бы она была чистой функцией. Примерном изолированной детерминированный последовательно-
многоразовый операции является, например, запись в лог `trace : !(String ⊸ Unit)`.
Следует, однако, отметить что операция записи в лог является последовательно-, а не
параллельно-многоразовой и поэтому может замедлять вычисление соответствующей функции, препятствуя
автопараллелизации (в паталогических случаях замедление может оказаться экспоненциальным).

* * *

Я обещал про ложную дихотомию. Итак, чисто функциональные языки очень удобны для строгого
математического рассмотрения и статического анализа, ещё они часто удобны для написания программ,
преобразующих данные, где всё большей частью идёт по happy path и к тому же не нужен контроль за
эффективностью алгоритмов, а важна корректность.

Однако для всех остальных применений такие языки в чистом виде не годятся. Чтобы писать на них
интерактивные программы (то есть взаимодействовать со внешней физической реальностью) и/или
как-то удобно моделировать физическую реальность, нужно эти языки расширять. Можно расширять
при помощи first-class support of objects, можно расширять при помощи библиотек-фреймворков,
позволяющих говорить об объектах иносказательно, для чего, как правило, используется понятие
монад.

Оба подхода имеют очевидные преимущества, и из копий, сломанных в спорах об них, можно сложить
небольшую обитаемую планету. Я убеждён, что правильный подход состоит в том, чтобы декларативное
описание в терминах монад и их интерпретаторов можно было определять и доопределять в библиотеках
(you can have it as custum as you want), а потом импортировать определение в скоуп и иметь внутри
скоупа first-class support объектов.
Это возможно в точности потому, что монадическое представление объекта, то есть его описание в
терминах образующих (операций над объектом) и отношений (аксиом, характеризующих относительную
независимость и детерминированность этих операторов) играет для объектов в точности ту же роль,
какую для значений играют типы. Типы исчерпывающе задают, что с их значениями можно делать
синтаксически, и как значения при этом себя ведут. Монадические представления делают это для
объектов.