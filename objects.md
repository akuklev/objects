Объекты и Значения
==================

Сложно найти в истории языков программирования что-то, что нанесло больший ущерб отрасли, чем непонимание фундаментально разной концептуальной природы объектов и значений и бесчисленные попытки расчесать их под одну гребёнку. Объекты — единицы моделирования материального мира. Значения — единицы информации.

Все люди воспринимают материальный мир и думают о нём в терминах объектов. В зависимости от предметной области это могут быть, например, яблоки и груши, ордера и квитанции, поезда и станции, или электроны и фотоны. Если пытаться предельно точно описывать физическую реальность, очень сложно описать даже что такое яблоко и где в точности его физические границы — скажем, где кончается плодоножка и начинается собственно яблоко. Тем не менее чтобы как-то описывать окружающую действительность и рассуждать о ней, необходимо смириться с неточностями, провести условные границы и разложить мир на идеализированные единицы моделирования — это и есть объекты. Канонический пример объекта в программировании — изменяемая переменная (= ячейка памяти), содержащая изменяемое целочисленное значение. 

Математика и чисто-функциональные (purely functional) языки программирования оперируют не объектами, но значениями. Значениями в математическом, платоническом смысле — такими, как например, число 2.

К объектам применимо понятие “тот же самый, один и тот же” (same). Так в двух разных ящиках могут лежать равные числа, но это не делает их одним и тем же ящиком — если в одном поменять значение, оно не поменяется в другом. Объекты могут возникать/порождаться и исчезать/поглощаться, к ним применимо понятие жизненного цикла (lifecycle).

К значениям, напротив, применимо понятие “равный” (equal), но не “то же”. Быть равными — это свойство пары значений: равенство может быть доказано или опровергнуто, а вот быть одним и тем же объектом можно только по определению.
Также неприменимо к значениям понятие жизненного цикла, про них даже нельзя сказать что они “всегда были и будут” — они просто вообще вне времени и вне материального мира. Они — информация, отделённая от ностеля.

Для большинства из нас концепция объекта куда более привычна, чем концепция значения — поэтому легко предположить, что значения это какая-то сложная и непонятная математическая абстракция, в то время как объекты просты и наглядны. На деле ситуация обстоит ровно противоположным образом: для описания свойств и взаимоотношений значений, и строгих рассуждений о них математики ещё полтора века назад [Frege1879] разработали формализованный язык, называемый **исчислением предикатов**. Десятилетия всесторонних исследований и практического использования показали его корректность и достаточную выразительность для всевозможных практических нужд, выработался и стабилизировался современный удобный синтаксис. А вот как раз инструментарий для рассуждений об объектах на данный момент всё ещё является предметом активных исследований.

Аналогично, императивные (в том числе императивные объектно-ориентированные) языки программирования воспринмаются, как что-то простое, а чисто-функциональные языки как нечто очень сложное. И это верно в том смысле, что функциональные языки сложнее изучить. Дело тут в том, что все мы с раннего детства знакомы с рецептами, инструкциями по сборке шкафов и пользованию электроприборами — думать в терминах объектов и последовательных действиях над ними нам _привычно_, в то время как думать в терминах значений и их преобразований привычно только профессиональным математикам.


В контексте вышесказанного понятно, почему чисто-функциональные языки программирования на данный момент гораздо более приспособлены к тому, чтобы про написанные на них программы можно было делать какие-либо выводы: эти языки программирования оперируют лишь значениями, в отношении которых мы имеем развитый инструментарий для рассуждений.

Ниже я продемонстрирую, как шаг за шагом добавить в чисто-функциональный язык программирования элементы, позволяющие оперировать не только значениями, но и объектами, не теряя в строгости. В примерах я буду использовать вымышленный чисто-функциональный язык с синтаксисом на основе Котлина.

Даже если вы не намереваетесь пользоваться таким языком программирования, понимание его устройства поможет лучше понять многие моменты, касающиеся параллелизации, out-of-order execution, а также на некоторые тонкости, возникающие в многопоточном программировании.

§ Чисто-функциональные языки
----------------------------

Программы на императивных языках программирования в первом приближении представляют из себя последовательность инструкций — приказов компьютеру (или переферийному устройству) совершить какое-либо действие. Скажем `print("Hello")` это инструкция напечатать слово “Hello”.

В чисто-функциональных языках программирования не существует такой синтаксической категории как инструкции. В таких языках есть лишь выражения (`2·a + 3`) и определения (`a := 1`, `f(x) := x`).  
Выражения описывают как вычислить значение, и взаимозаменимы с этим значением. Определения служат лишь для удобства, все определения можно убрать, заменив каждое упоминание определяемого на соответствующее определение, и программа останется идентичной.

При наличии инструкций заменяемость на значение уже не работает. Для примера предположим, что в нашем языке есть оператор под названием `!rand`, недетерминистски генерирующий случайное целое число. Рассмотрим следующие две программы, которые должны бы быть эквивалентны:
```kotlin
val n := !rand
n + n
```
и `!rand + !rand`. Первая программа всегда выдаёт чётное число, ведь она складывает одно и то же случайное число с самим собой, а вторая складывает два независимых случайных числа, и результат вполне может быть нечётным. Так добавление `!rand` нарушило чистоту языка, и аннулирует возможность рассуждения о свойствах программы при помощи логики-первого-порядка-с-равенством, ведь тут нарушается определяющее свойство равенства — подстановочность.

Аналогичную проблему вызывает и добавление в языка оператора `!trace`, которой никак не влияет на вычисления, а лишь записывает что-то в лог. Допустим, с целью отладки программист добавил инструкцию `!trace` в определение операции сложения, и всякий раз при сложении двух чисел выводит их сумму в лог. Такое изменение операции сложения делает выражение использующее операцию сложения не взаимозаменяемым с ее результатом. В чисто-функциональном языке следующие три программы обязаны быль эквивалентны:
`(1 + 2) + 3`, `1 + (2 + 3)`, `6`. С точки зрения результата они действительно эквивалентны, но с точки зрения эффектов неидентичны. Первая при выполнении выведет в лог `3, 6`, вторая `5, 6`, третья не выведет вообще ничего. Полагаясь на чистоту языка можно делать мощные оптимизирующие компиляторы, но стоит нам добавить в язык казалось бы безобидный оператор `!trace`, оптимизирующие компиляторы входят в непредсказуемый конфликт с пригодностью логов для post-mortem анализа.

§ Инструкции и программы
------------------------

Рассмотрим выражение `2·a + 3`. В нём используются два литерала (2 и 3) и три так называемых символа: численная переменная `a` и два бинарных оператора на числах — `(+)` и `(·)`. Контекстом называется набор доступных для использования внутри выражения символов и операторов с указанием их сигнатур, в частности для выражения `2·a + 3` контекст выглядит следующим образом:
```
a : Int, (+) : Int -> Int -> Int, (·) : Int -> Int -> Int
```

В чисто-функциональных языках программирвоания все символы и операторы представляют собой значения и являются либо константами, определёнными выше по течению или импортированными в скоуп, либо именами аргументов функций, внутри которых мы находимся. Более того, константы всегда могут быть выражены через создание и немедленное применение анонимной функции:
```kotlin
val a := expr
2·a + 3
```
— это то же самое, что `expr ▸ {a ↦ 2·a + 3}`, где `(▸)` оператор применения справа налево `x ▸ f` := `f(x)`.

Программой (routine) мы будем называть последовательность инструкций, возможно с ветвлениями и циклами. Инструкции (statements) внешне похожи на выражения, но их контексты могут содержать особые операторы, представляющие собой не значения, а действия или запросы, такие как вышеприведённые `!rand` и `!trace`. Как было объяснено выше, такие операторы не взаимозаменяемы с результатом своего вызова. Чтобы это радикально отличающее их свойство сразу было заметно, мы будем всегда начинать из названия с восклицательного знака. Отметим также, что хорошо знакомые всем программистам инструкции `throw` и `return` тоже можно рассматривать как !-операторы.

В зависимости от своей сигнатуры !-операторы бывают:
* одноразовыми (one-shot), как `!throw` — в каждой ветви выполнения такой оператор можно использовать не более одного раза
* принудительно одноразовыми (obligatory one-shot), как `!return` — в каждой ветви выполнения такой оператор можно и необходимо использовать ровно один раз
* параллельно многоразовыми, как `!rand` — такой оператор можно использовать произвольное число раз, причём даже более одного раза внутри одной инструкции; в отношении таких операторов важен только сам факт каждого вызова, но играет роли в каком порядке совершаются эти вызовы.
* последовательно многоразовыми как `!trace` — в программе такой оператор можно использовать много раз, но в каждой отдельной инструкции не более одного раза. Для последовательно многоразовых операторов существенен порядок вызовов. Более того, сама сигнатура оператора может меняться после каждого вызова (мы выбрали Котлин в частности потому, что он поддерживает smart-касты). “Под капотом” последовательно многоразовые !-операторы это одноразовые операторы, которые после вызова возвращают в контекст новый !-оператор с таким же названием вместо себя.

Обозначения для типов !-операторов проистекают из так называемой линейной логики.
Тип принудительно одноразового !-оператора будем обозначать через `X ⊸ Y`:
```kotlin
!return : T ⊸ Nothing
```

Тип (не более чем) одноразового !-оператора будем обозначать через `¿T`:
```kotlin
!throw : ¿(Throwable ⊸ Nothing)
```

Тип параллельно-многразового !-оператора будем обозначать через `!T`:
```
!rand : !Int
```

Как же описать тип `T` последовательно-многоразового оператора `!trace`? Напомню, что “под капотом” многоразовые !-операторы суть одноразовые, возвращающие (возможно наряду с некоторым значением) свою замену. Стало быть тип `T` оператора `!trace` должен удовлетворять рекурсивному соотношению `T = String ⊸ T`. Для порождения типов !-операторов, удовлетворяющих подобным рекурсивным соотношениям мы будем использовать специальные сигнатуры уже хорошо знакомые пользователям Котлина. Они называются там интерфейсами:
```
interface Log {
  fun !trace(msg : String)
}
```

§ Объекты и Интерфейсы
----------------------

Выше уже упоминался хрестоматийный пример объекта — изменяемая (мутабельная) переменная. На Котлине её интерфейс можно было бы описать так:
```kotlin
interface Variable<T> {
   val !get : T
   fun !set(v : T)
}
```

В нашем расширении чисто-функционального Котлин мы допустим определения интерфейсов, но не будем разрешать использовать интерфейсы в качестве типов аргументов, переменных и возвращаемых значений. Таким образом мы эффективно потребуем, чтобы типы всех методов и свойств, декларируемых в интерфейсах, равно как и типы их аргументов были типами значений.

Как же можно использовать интерфейсы, если мы пока запрещаем чтобы переменные или аргументы функций использовали интерфейсы в качестве типов? А очень просто — используя механизм, известный в Котлине как extension methods. Для всякого интерфейса I мы можем написать новый метод `foo`
```kotlin
fun I.foo(args) : ResultT {
   ...
}
```
в теле которого все методы, описанные в интерфейсе I, доступны в качестве !-операторов. Объекты — сущности удовлетворяющие интерфейсам, мы не видим их напрямую в языке, но имеем к ним доступ через их методы. Имеющееся в распоряжении в Котлине механизмы описания интерфейсов позволяют описывать всевозможные мутабельные объекты и внешние сервисы с заданным интерфейсом. В этом случае методы — запросы к такому сервису.

Небольшое расширение синтаксиса интерфейсов позволит добавить поддержку нетривиального жизненного цикла объектов. Мы позволим методам в интерфейсах менять тип this (мы выбрали Котлин в частности потому, что он поддерживает smart-касты). В частности, можно поменять тип this на Nothing и таким образом указать, что метод поглащает объект, на котором был вызван:
```kotlin
interface OutputStream {
   fun !append(s : String)
   fun !close() nextState(Nothing)
}
```

Теперь вместо постоянного набора методов имеется конечный автомат состояний объекта, и доступные методы зависят от текущего состояния. Диаграма этого конечного автомата описывает жизненный цикл объекта.


Если сделать Котлин зависимо-типизированным языком (то есть таким, что параметрами типов могут являться значения, например `List<T, size = n>`), то в интерфейсах допустимо, чтобы типы возвращаемых значений методов и состояния, в которые переходит в результате вызова метода this, зависели от аргументов метода и параметров исходного типа this. (NB: Для знатоков теории категорий отмечу что этими расширениями интерфейсы соответствуют свободно-порождённым зависимым комонадам. Зависимые комонады также известны как правые расширения Кана.)

Используя синтаксис val (properties with a getter) в интерфейсах, мы можем также описать `!rand`: 
```kotlin
interface RandGen {
  val !rand: Int
}
```

Использование в extension methods не единственный способ использования объектов. Ниже мы опишем, например, ситуации, когда мы можем локально породить изолированный объект, поработать с ним, а затем закрыть его, извлекая значение — так работают Котлиновские typesafe-builder'ы. Изолированные объекты можно будет также одалживать, принимать и передавать во владение, но прежде нам необходимо дать определение изолированным объектам.

Равенство объектов
------------------

В мире объектов понятие равенства распадается на две модальности — равенство эффектов и равенство
результатов, которые мы будем обозначать через =e= и =r= соответственно.

Используя равенство эффектов мы можем указать важнейшее свойство оператора `!rand` — отсутствие побочных эффектов:
```kotlin
interface RandGen {
  val !rand: Int
  
  contracts {
    {!rand} =e= {}
  }
}
```

Равенство результатов вообще говоря нерефлексивное, например `!rand =r= !rand` НЕ
выполняется. Оператор `!foo : X ⊸ Y` называется детерминированным в точности, если
для него выполняется рефлексивность равенства результатов, т. е.
будучи вызван с одинаковым аргументом он всякий раз выдаёт одинаковые результат:
`a = b` влечёт `!foo(a) =r= !foo(b)`.

Также обратим внимание, что равенство результатов не влечёт равенства эффектов:
с точки зрения результатов любые два запроса, возвращающие Unit, равны, но с точки зрения
эффектов `!trace("Hello")` и `!trace("Goodbye")` очевидно разные.

Равенство эффектов напротив рефлексивное, но не влечёт равенства результатов. Равенство эффектов
может быть использована для выражения независимости (параллелизуемости) запросов. Мы можем, например,
постулировать, что запись в независимые потоки вывода (например, `!print` и `!trace`) коммутирует:
```kotlin
{!print(x); !trace(y)} =e= {!trace(y); !print(x)}
```

Информация о коммутировании тех или иных вызовов открывает богатые возможности для оптимизирующей
компиляции: компилятор, если это способно повысить производительность, может переставлять вызовы местами или даже вовсе параллелизовать их.

Объекты obj1 и obj2 называют независимыми вызовы методов obj1 и методов obj2 коммутируют между собой.
Независимость объектов имплицирует отсутствие коммуникации между ними, но не означает
детерминированности.

Изолированным называется объект независимых от любых других объектов. Для `RandGen` и `Log`лога это
свойство постулируется*, для детерминистски работающих мутабельных объектов выполняется по построению. 

(* Мы постулируем, что считывание из собственных логов невозможно в рантайме ни прямо, ни опосредованно, иначе логи можно было бы использовать как хранилище информации.)

Методами теории категорий можно показать, что с процедурой, использующей изолированные  
детерминированные объекты, и не экспортирующей их наружу, можно обращаться в точности
также как если бы она была чистой функцией. Благодаря этому обстоятельству в случае изолированных объектов можно допустить передачу и получение объектов в качестве аргументов функции при контроли владения (см. Rust).

В заключение секции приведём описание интерфейса `мутабельная переменная` с контрактами, в полной мере определяющими её поведение:

```kotlin
interface Variable<T> {
   val !get : T?
   fun !set(v : T)
   
   contracts {
     !get =r= !get
     {!get} =e= {}

     {!set(x1); !set(x2)} =e= {!set(x2)}     
     {!set(x); !get} =r= x     
   }
}
```

Обратите внимание, что из контрактов и сигнатуры прямо следует, что `!get` может возвращать `null` только до первого вызова `!set`, но не очевидно, что он обязан выдавать именно `null` до первого вызова `!set`. Однако легко показать, что это единственное возможное поведение, если в качестве параметра `T` подставить `Nothing`, а из параметричности следует что при использовании любого другого типа поведение должно оставаться таким же.

Открытый вопрос 1: Такого рода описания должны порождать монаду Дейкстры (https://arxiv.org/abs/1903.01237), предоставляющую удобный инструмент для формальной верификации программ. Как именно построить монаду дейкстры для произвольного интерфейса, снабженного исчерпывающими контрактами?

Открытый вопрос 2: Как именно контракты и монады Дейкстры связаны с сепарационной логикой?

Открытый вопрос 3: Как взаимодействуют и взаимосвязаны объекты и корутины? Свет эти вопросы с теоретической точки зрения проливает линейная логика Girard'а и её расширения, в первую очередь Adjoint logics Frank'а Pfenning'а. С практической точки зрения механизмы взаимодействия должны быть описуемы в терминах join calculus.

* * *

Праздные рассуждения, которые я пока не придумал куда засунуть
--------------------------------------------------------------

Чисто функциональные языки очень удобны для строгого математического рассмотрения и статического анализа, ещё они часто удобны для написания программ, преобразующих данные, где всё большей частью идёт по happy path и к тому же не нужен контроль за
эффективностью алгоритмов, а важна корректность.

Для всех остальных применений такие языки плохо приспособлены. 
Чтобы писать на них
интерактивные программы (то есть взаимодействовать со внешней физической реальностью) и/или
как-то удобно моделировать физическую реальность, нужно эти языки расширять. Можно расширять
при помощи first-class support of objects, можно расширять при помощи библиотек-фреймворков,
позволяющих говорить об объектах иносказательно, для чего, как правило, используется концепция
монад.

Оба подхода имеют очевидные преимущества, и из копий, сломанных в спорах об них, можно сложить
небольшую обитаемую планету. Я убеждён, что правильный подход состоит в том, чтобы декларативное
описание в терминах монад и их интерпретаторов можно было определять и доопределять в библиотеках
(you can have it as custom as you want), а потом импортировать определение в скоуп и иметь внутри
скоупа first-class support объектов.
Это возможно в точности потому, что монадическое представление объекта, то есть его описание в
терминах образующих (операций над объектом) и отношений (аксиом, характеризующих относительную
независимость и детерминированность этих операторов) играет для объектов в точности ту же роль,
какую для значений играют типы. Типы исчерпывающе задают, что с их значениями можно делать
синтаксически, и как значения при этом себя ведут. Монадические представления делают это для
объектов.