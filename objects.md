Объекты и Значения
==================

Центральным понятием в объектно-ориентированном программировании (кто бы мог подумать) является понятие объекта — идеализированного материального объекта. Пример такого “материального объекта”, известный каждому, кто хоть раз программировал, — изменяемая переменная, содержащая целочисленное значение: такой “ящик” где лежит число.

Понятие объекта используется не только в объектно-ориентированном программировании, оно используется вообще при любом императивном программировании. Машинный код скомпилированной программы это последовательность инструкций, оперирующих объектами — регистрами процессора (ящиками с набором битов), оперативной памятью и переферийными устройствами. Так называемые текстовые физические задачи из школьного курса (“В 13:00 поезд отправился из Пункта А в Пункт Б [...]”) тоже описываются в терминах объектов, в терминах объектов описываются физические эксперименты и большая часть физических теорий. Понятие объекта — центральное при описании и моделировании как “бизнес-процессов”, так и физической реальности.

На пути развития объектно-ориентированного подхода к программированию и моделированию была допущена огромная историческая ошибка, негативные последствия которой ещё предстоит оценить: попытка моделировать при помощи объектов то, что ими совершенно не является — значения.

Математика и чисто-функциональные языки программирования оперируют не объектами, но значениями. Значениями в математическом, платоническом смысле, например целое число 2.

К объектам применимо понятие “тот же самый, один и тот же” (same). Так в двух разных ящиках могут лежать равные числа, но это не делает из одним и тем же ящиком — если в одном поменять значение, оно не поменяется в другом. Объекты могут возникать/порождаться и исчезать/поглощаться, к ним применимо понятие жизненного цикла (lifecycle). В зависимости от того, что и как именно мы моделируем, может оказаться что те или иные объекты возможно “всегда были” и/или “всегда будут”. Не смотря на то,
что у таких объектов как будто нет “жизненного цикла” (по меньшей мере невырожденного), к ним применима сама концепция “материального существования” в какой-то момент при каких-то условиях.

К значениям, напротив, применимо понятие “равный” (equal, identifiable), но не “то же”. Быть равнми — это свойство пары значений: равенство может быть доказано или опровергнуто, а вот быть одним и тем же объектом можно только по определению.
Также неприменимо к значениям понятие жизненного цикла, про них даже нельзя сказать что они “всегда были и будут” — они просто вообще вне времени, вне “материального существования”. Они — информация, отделённая от ностеля.

Для большинства из нас концепция объекта куда более привычна, чем концепция значения. Поэтому легко предположить, что значения это какая-то сложная и непонятная математическая абстракция, в то время как объекты просты и наглядны. На деле ситуация обстоит ровно противоположным образом: для рассуждений о значениях математики разработали строгий формальный язык, называемый логикой первого порядка с равенством. За почти полтора столетия существования логики первого порядка, математики, логики и философы успели изучить её вдоль и поперёк, изучить все подводные камни и убедиться, что язык этот исчерпывающе достаточен для описания значений, их свойств и взаимоотношений, а также строких рассуждения о них. В то же время удобный инструментарий для рассуждения об объектах всё ещё является предметом активных исследований и по-видимому далёк ещё от своей финальной формы.

В контексте вышесказанного становится понятно, почему чисто-функциональные языки программирования на данный момент гораздо более приспособлены к тому, чтобы анализировать написанные на них программы и делать про эти программы какие-либо выводы: эти языки программирования оперируют лишь значениями, в отношении которых мы имеем развитый и исчерпывающий инструментарий для рассуждений. Ниже я продемонстрирую, как шаг за шагом добавить в чисто-функциональный язык программирования элементы, позволяющие оперировать не только значениями, но и объектами, не теряя в строгости. В качестве основы я возьму вымышленный чисто-функциональный язык с синтаксисом на основе Котлина.

Даже если вы никогда не будете пользоваться таким языком программирования, понимание его устройства прольёт свет на многие моменты, касающиеся параллелизации, out-of-order execution, а также на многие тонкости, возникающие в многопоточном программировании.

Чисто-функциональные языки
--------------------------

Программы на императивных языках программирования в первом приближении представляют из себя последовательность инструкций — приказов компьютеру (или переферийному устройству) совершить какое-либо действие. Скажем `print("Hello")` это инструкция напечатать слово “Hello”.

В чисто-функциональных языках программирования не существует такой синтаксической категории как инструкции. В таких языках есть лишь определения (`a := 1`, `f(x) := x`) и выражения (`2·a + 3`).  
Определения служат лишь для удобства, все определения можно убрать, заменив каждое упоминание определяемого на определения, и программа останется идентичной.
Выражения описывают как вычислить значение, и взаимозаменимы с этим значением.

Если в языке есть инструкции, заменяемость на значение уже не работает. Для примера предположим, что в нашем языке есть инструкция `RAND`, недетерминистски генерирующая случайное целое число. Рассмотрим следующие две программы, которые должны бы быть эквивалентны:
```kotlin
val n := RAND
n + n
```
и `RAND + RAND`. Первая программа всегда выдаёт чётное число, ведь она складывает одно и то же случайное число с самим собой, а вторая складывает два независимых случайных числа, и результат вполне может быть нечётным. Так добавление инструкции `RAND` нарушило чистоту языка, и аннулирует возможность рассуждения о свойствах программы при помощи логики-первого-порядка-с-равенством, ведь тут нарушается определяющее свойство равенства.

Аналогичную проблему вызывает и добавление в язык инструкции `TRACE`, которая никак не влияет на вычисления, а лишь записывает что-то в лог. Допустим, с целью отладки программист добавил инструкцию TRACE в определение операции сложения, и всякий раз при сложении двух чисел выводит их сумму в лог. Правило подстановочности требует, чтобы следующие три программы были эквивалентны:
`(1 + 2) + 3`, `1 + (2 + 3)`, `6`. С точки зрения результата они действительно эквивалентны, но с точки зрения эффектов неидентичны. Первая при выполнении выведет в лог `3, 6`, вторая `5, 6`, третья не выведет вообще ничего. Полагаясь на чистоту языка можно делать как мощные оптимизирующие компиляторы, но стоит нам добавить в язык казалось бы безобидную инструкцию TRACE, оптимизирующие компиляторы входят в непредсказуемый конфликт с пригодностью логов для post-mortem анализа.

Строгие языки с поддержкой объектов: Пример на пробу
----------------------------------------------------

В чисто-функциональныз языках программирования все аргументы всех функций представляют собой значения, и сами функции естественно тоже значения. 

Сейчас мы попробуем расширить понятие функции, чтобы добавить в язык возможность оперировать объектами.

“Функцию”, которая принимает в качестве аргументов ещё и объект(ы) уже можно назвать
функцией только в кавычках, т.к. она сама перестаёт быть значением в математическом смысле.
Давайте будем называть такие “функции” методами, и немедленно рассмотрим один такой метод:
```kotlin
fun main(args : List<String>, STDOUT : !(String ⊸ Unit)) {
  for(i in args) STDOUT(i ++ "\n")
}
```

Тут метод `main` принимает
кроме значения `args` ещё и объект `STDOUT` с устрашающей сигнатурой `!(String ⊸ Unit)`, которую
мы сейчас разберём подробнее.

Базовый класс объектов — одноразовые (one-shot) request endpoints, их тип обозначается через
```
ReqT ⊸ RespT
```
где `ReqT` и `RespT` два каких-то типа значений, называемых “тип запроса” и “тип ответа”.
Объекту такого типа можно скормить значение типа `ReqT` и в ответ получишь значение типа
`RespT`.

Если некая процедура приняла аргумент `EP : ReqT ⊸ RespT`, то в каждой ветви своего выполнения
она может (и должна) вызвать EP ровно один раз, не больше и не меньше. У нас имеются три
модификатора типов объектов:
- `EP : ¿(ReqT ⊸ RespT)` означает что получатель не обязан пользоваться EP. Пользоваться больше
одного раза (в каждой ветви исполнения) всё ещё нельзя, но требование пользоваться не __меньше__
убирается.
- `EP : *(ReqT ⊸ RespT)` означает что EP параллельно-многоразовый endpoint, то есть им можно
пользоваться ноль или более раз в каждой ветви выполнения. Такая сигнатура подходит, например,
физическому генератору случайных чисел `RAND : *(Unit ⊸ Int32)`.
- `EP : !(ReqT ⊸ RespT)` означает что EP последовательно-многоразовый endpoint. Под капотом
это такой тип объектов `S`, для которого выполняется `S = ¿(ReqT ⊸ RespT ⊗ S)`. То есть это
необязательный к использованию endpoint, возвращающий при использовании не только значение
типа `RespT`, но ещё один endpoint идентичного типа на замену себе. Именно с этой сигнатурой
мы сталкнулись в методе `main` выше. Там поток `STDOUT` это последовательно-многоразовый
request endpoint, принимающий строки и возвращающий Unit.

Программы, интерактивность которых сводится к command-line interface могут рассматриваться
как методы сигнатуры
```kotlin
fun main(args : List<String>, TTY : !(String ⊸ String))
```

Sidenote: Как и в случае с последовательно-многоразовыми, параллельно-многоразовые эндпоинты можно
рассматривать как синтаксический сахар над более низкоуровневой конструкцией. Можно считать, что
это объекты сигнатуры `S`, снабженные структурой комоноида, то есть операциями `discard` (так
называемая ко-единица) и `duplicate` (так называемая ко-композиция), в отношении которых
выполняются аксиомы, двойственные обычным аксомам моноида.


Равенство одноразовых запросов
------------------------------

В мире объектов понятие равенства распадается на две модальности — равенство эффектов и равенство
результатов, которые мы будем обозначать через =e= и =r= соответственно. 

Мы говорим, что запрос `EP : ReqT ⊸ RespT` детерминирован, если будучи вызван с одинаковым
аргументом он всякий раз выдаёт одинаковые результаты, т.е.
`a = b` влечёт `EP(a) =r= EP(b)`.

Обратим внимание, что это равенство вообще говоря нерефлексивное, например `RAND =r= RAND` НЕ
выполняется. Также обратим внимание, что равенство результатов не влечёт равенства эффектов:
с точки зрения результатов любые два запроса, возвращающие Unit, равны, но с точки зрения
эффектов `STDOUT("Hello")` и `STDOUT("Goodbye")` очевидно разные.

Равенство эффектов напротив рефлексивное, но не влечёт равенства результатов. Равенство эффектов
может быть использована для выражения независимости (параллелизуемости) запросов. Так например
запись в независимые потоки вывода (например, `STDOUT` и `STDERR`) независима, что мы можем
выразить через `{STDOUT(x); STDERR(y)} =e= {STDERR(y); STDOUT(x)}`.

Независимость двух сервисов отсутствие коммуникации между ними, но не означает детерминированности.
Пусть например программа
```kotlin
fun main(args : List<String>, TTY1 : !(String ⊸ String),
                              TTY2 : !(String ⊸ String))
```
взаимодействует с двумя пользователями через интерфейсы `TTY1` и `TTY2` соответственно.
Независимость `TTY1` и `TTY2` обеспечена в точности если физически исключена возможность
коммуникации пользователей между запросами. Знание о независимости запросов влияет на возможность
из параллелизовывать и таким образом производительность программы.

Замкнутые объекты и изолированность
-----------------------------------

Изолированностью называется свойство запроса `EP : X ⊸ Y` не влиять на другие запросы и не быть
подверженным влиянию других запросов. Так например запись в лог (программное считывание из лога
мы постулируем невозможным) является примером изолированного запроса. Изолированность запроса
`EP` мы можем выразить следующим образом: Для любого другого `EP' : X' ⊸ Y'` и
любых `x : X`, `x' : X'` выполняется

```
{
  val a := EP(x)
  val b := EP'(x')
  return (a, b)
} =r= {
  val b := EP'(x')
  val a := EP(x)
  return (a, b)
}
```

Замкнутым объектом называется совокупность запросов, изолированных от любых внешних запросов,
но не друг от друга, а сами эти запросы назваются методами объекта.

Так например, мутабельная переменная типа `X` это изолированный объект, имеющий методы
```
set : X ⊸ Unit
get : Unit ⊸ X?
```
со следующими свойствами:
```
{set(x); set(x')} =e= {set(x')}
{set(x); get} =r= x
get =r= get
{get} =e= {}

```
То есть,
1) последовательность `set`ов эффективно эквивалентна последнему из них;
2) `get` возвращает то, что было `set`-нуто (в последний раз, см. свойство 1);
3) `get` детерминистский (кстати, `set` тоже, просто потому что возвращает `Unit`)
4) `get` не имеет эффектов

Из свойств 1-3 следует что `get` возвращает null на неинициализированной переменной и только на ней.

Такого рода описания порождают монаду Дейкстры (https://arxiv.org/abs/1903.01237), предоставляющую удобный инструмент reasoning'а в процедурах. Однако для более сложных случаев нужно разобраться как описывать незамкнутые подобъекты замкнутого объекта (sharing & ownership) так чтобы монада Дейкстры оснащалась полным инструментарием сепарационной логики.

Ещё нужно отметить, что могут быть объекты, имеющие всего один метод. Например уже упоминавшийся
`RAND`.

N.B. Незамкнутые объекты называем сервисами или агентами.

Когда объекты ведут себя как значения
-------------------------------------

Методами теории категорий можно показать, что с процедурой, использующей изолированные
детерминированные параллельно- или последовательно-многоразовые операции, можно обращаться в точностью
также как если бы она была чистой функцией. Примерном изолированной детерминированный последовательно-
многоразовый операции является, например, запись в лог `trace : !(String ⊸ Unit)`.
Следует, однако, отметить что операция записи в лог является последовательно-, а не
параллельно-многоразовой и поэтому может замедлять вычисление соответствующей функции, препятствуя
автопараллелизации (в паталогических случаях замедление может оказаться экспоненциальным).

* * *

Я обещал про ложную дихотомию. Итак, чисто функциональные языки очень удобны для строгого
математического рассмотрения и статического анализа, ещё они часто удобны для написания программ,
преобразующих данные, где всё большей частью идёт по happy path и к тому же не нужен контроль за
эффективностью алгоритмов, а важна корректность.

Однако для всех остальных применений такие языки в чистом виде не годятся. Чтобы писать на них
интерактивные программы (то есть взаимодействовать со внешней физической реальностью) и/или
как-то удобно моделировать физическую реальность, нужно эти языки расширять. Можно расширять
при помощи first-class support of objects, можно расширять при помощи библиотек-фреймворков,
позволяющих говорить об объектах иносказательно, для чего, как правило, используется понятие
монад.

Оба подхода имеют очевидные преимущества, и из копий, сломанных в спорах об них, можно сложить
небольшую обитаемую планету. Я убеждён, что правильный подход состоит в том, чтобы декларативное
описание в терминах монад и их интерпретаторов можно было определять и доопределять в библиотеках
(you can have it as custom as you want), а потом импортировать определение в скоуп и иметь внутри
скоупа first-class support объектов.
Это возможно в точности потому, что монадическое представление объекта, то есть его описание в
терминах образующих (операций над объектом) и отношений (аксиом, характеризующих относительную
независимость и детерминированность этих операторов) играет для объектов в точности ту же роль,
какую для значений играют типы. Типы исчерпывающе задают, что с их значениями можно делать
синтаксически, и как значения при этом себя ведут. Монадические представления делают это для
объектов.