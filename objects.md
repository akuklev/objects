Stratified Kotlin — Deconstruction of concurrent object-oriented programming
============================================================================


§ Объекты и Данные
------------------

Когда-то [Tony Hoare](https://en.wikipedia.org/wiki/Tony_Hoare) назвал [null pointers](https://en.wikipedia.org/wiki/Null_pointer) “ошибкой на миллиард долларов”. В истории языков программирования есть кое-что обходящееся, вероятно, ещё дороже: игнорирование фундаментальной разницы между данными и объектами.

С рождения мы воспринимаем окружающий мир и процессы в нём через картины и ощущения, и этого достаточно для мышления при помощи эвристик аналогий. Но чтобы сделать возможными чёткие инструкции и строгие рассуждения, необходимо провести условные границы и разложить мир на **идеализированные единицы моделирования — объекты**. В зависимости от предметной области это могут быть, например, яблоки и груши, ордера и квитанции, поезда и станции или электроны и фотоны. Мы учимся этому, когда учимся говорить и думать словами, а оттачиваем, занимаясь программированием (по части «чётких инструкций») и математикой (по части «строгих рассуждений»). Канонический пример материального объекта в программировании — ячейка памяти, содержащая изменяемое целочисленное значение.

Теперь допустим, что мы считали значение из ячейки памяти и взвесили яблоко, установив, что `X.value = 2` и `Apple1.weight = 93g`. Упоминающиеся тут ячейка памяти `X` и яблоко `Apple1` — материальные объекты, а вот «целое число 2» и «93 грамма» — платонические “объекты”, существующие исключительно в мире математических абстракций. В их отношении мы будем применять термины данные (мн.ч) и значение (ед.ч). **Данные — информация, отделённая от носителя и контекста**.

К объектам применимо понятие “тот же самый, один и тот же” (same). Так в двух разных ящиках могут лежать равные числа, но это не делает их одним и тем же ящиком — если в одном поменять значение, оно не поменяется в другом. Объекты могут возникать/порождаться и исчезать/поглощаться, к ним применимо понятие жизненного цикла (lifecycle).

К значениям, применимо понятие “равный” (equal), но не “тот же”. Быть равными — это свойство пары значений: равенство может быть доказано или опровергнуто, а вот быть одним и тем же объектом можно только по определению. Более того, невозможно вообще корректно определить пару из объекта с самим собой — пара объектов это автоматически пара двух разных объектов.
Также неприменимо к значениям понятие жизненного цикла, про них даже нельзя сказать что они “всегда были и будут” — они просто вне времени и материального мира.

Теперь, ознакомившись с базовыми понятиями и обрисовав фундаментальные различия, давайте разберёмся зачем проектировать языки программирования с учётом этих различий. В примерах я буду пользоваться вымышленным языком с синтаксисом на основе Kotlin'а.

§ Команды и чистые функции
--------------------------

Первый в современном понимании язык программирования появился в 1957 году, это был FORTRAN. Как и во всех современных императивных языках, программа на Фортране представляет собой последовательность инструкций. Два основных вида инструкций — определения (`a := 1`) и команды (`print("Hello")`). Внутри определений и в качестве аргументов команд могут использоваться выражения:
```kotlin
val a := 60 · 24
print("1 day / 1 min = " ++ a)
```

Выражения описывают путь вычисления значения, и должны быть взаимозаменимы с этим значением. То есть, если вместо выражения сразу подставить его результат, программа не должна измениться. Выражения представляют из себя деревья применения функций к значениям. Скажем, `60 · 24` предписывает применить функцию `(·)` к значениям 60 и 24, `"1 day / 1 min =  " ++ a` применяет функцию конкатенации строк `(++)` к значениям `"1 day / 1 min = "` и `a`.

К сожалению, подавляющее большинство императивных языков программирования не различают чистые функции — функции, детерминистски вычисляющие значение из аргументов, без всяких побочных эффектов — и комманды, которые возвращают значение вообще говоря не детерминированное своими аргументами, и при выполнении которых могут производиться необратимые действия, например удаление файлов. На первый взгляд функции и команды логично объединить — и те, и другие могут принмать аргументы и возвращать значения. Объединение даёт экономию концепций и таким образом как будто уменьшает сложность языка, что же тут может быть плохого?
Проблема в том, что нельзя больше рассчитывать, что выражения взаимозаменимы со своими значениями. Теряется удобная ментальная модель, позволяющая думать о программе, просто смотря на неё. Теперь во всяком безобидно выглядящем выражении может скрываться плохо предсказуемое поведение.

Давайте рассмотрим две самые безобидные команды — `rand()`, которая генерирует аппаратное случайное целое число, и `trace(msg)`, которая никак не влияет на вычисления, а лишь записывает аргумент в лог. Обе эти команды никак не зависят от эффектов предыдущих команд, обе эти команды сами не имеют побочных эффектов, которые могли бы повлиять на дальнейшее выполнение: `rand()` не имеет никаких побочных эффектов вообще, а `trace(msg)` имеет побочный эффект, но программа не должна иметь возможности читать из собственных логов в runtime'е ни прямо, ни опосредованно, так что эффект иррелевантен для выполнения. Выражения, которые содержат не только вызовы чистых функций, но и вызовы команд, будем называть псевдовыражениями.

Если бы мы имели дело только с выражениями, следующие две программы были бы эквивалентны:
```kotlin
val n := rand()
n + n
```
и `rand() + rand()`. Однако первая программа всегда выдаёт чётное число, ведь она складывает одно и то же случайное число с самим собой, а вторая складывает два независимых случайных числа, и результат вполне может быть нечётным. Для псевдовыражений не выполняется взаимозаменяемость с результатом.

Теперь рассмотрим команду `trace()`. Допустим, с целью отладки программисты добавили ее в определение функции сложения, и всякий раз при сложении двух чисел выводит их сумму в лог. Если бы функция `(+)` оставалась чистой, следующие три программы обязаны быль эквивалентны:
`(1 + 2) + 3`, `1 + (2 + 3)`, `6`.

С точки зрения результата они действительно эквивалентны, но с точки зрения эффектов неидентичны. Первая при выполнении выведет в лог `3, 6`, вторая `5, 6`, третья не выведет вообще ничего. Полагаясь на подстановочность выражений можно делать мощные оптимизирующие компиляторы, но стоит нам добавить в язык казалось бы безобидную команду `trace()`, оптимизирующие компиляторы входят в непредсказуемый конфликт с пригодностью логов для post-mortem анализа.

Теперь рассмотрим команды с необратимыми эффектами. Пусть команда `delete(wildcard)` удаляет файлы, соответствующие паттерну `wildcard`, и возвращает количество удалённых файлов. Рассмотрим вот такую программу:
```kotlin
print( delete("*.tmp") · delete("*.*~") )
```

Что хотел сказать этим автор? Можно ли запустить оба процесса удаления одновременно, или нужно сперва произвести удаление слева от оператора `(·)`, а только потом то, которое справа? Если вы уже выбрали предпочтительный ответ, то теперь предположите, что в каталоге вообще не было файлов с расширением `.tmp`, и первая команда возвращает 0. Нужно ли в таком случае вообще производить второе удаление? Если допустимо было запустить оба процесса удаления одновременно, то можно ли напечатать 0 до завершения второго (ведь уже известно, что результат будет 0), или нужно дождаться завершения? Или может быть прервать второй процесс на пол-дороги? Эти решения предстоит принять и описать в спецификации проектировщикам языка, а пользователям языка предстоит их выучить, а чаще всего неожиданно наткнуться на них в процессе болезненной отладки. Вместо очень простой ментальной модели в случае выражений, для понимания псевдовыражений требуется знание замысловатых правил, зачастую являющихся результатом исторической случайности.

Смешение чистых функций и команд порождает лавину избыточной сложности (accidental complexity). Радикальным решением этой проблемы являются так называемые чисто-функциональные (purely functional) языки программирования, в которых вообще отсутствуют команды и оставлены одни чистые функции.

§ Преимущества и ограничения чисто-функциональных языков
--------------------------------------------------------

Для большинства из нас концепция объекта куда более привычна, чем концепция значения — потому легко предположить, что значения сложная в понимании и обращении математическая абстракция, в то время как объекты просты и наглядны. На деле ситуация обстоит противоположным образом.  
Для описания свойств и взаимоотношений значений, и строгих рассуждений о них математики ещё полтора века назад [Frege1879] разработали формализованный язык, называемый **исчислением предикатов**. Десятилетия теоретических исследований и практического использования исчисления предикатов позволили убедиться в его корректности и достаточной выразительности, понять все его возможности и ограничения, выработать удобный синтаксис. 

Когда говорят о чисто-функциональных языках программирования, часто упоминают, что у них есть “математическая основа“. Что имеется в виду и какие преимущества это даёт?

Чисто-функциональные языки программирования оперируют напрямую только и исключительно данными, что позволяет применять исчисление предикатов. Его выразительность гарантирует, что все свойства программ, не завиящие от устройства компилятора / модели вычисления, можно сформулировать. Так можно сформулировать требование, что функция `sort` всегда правильно сортирует, а функция `groupBy` правильно группирует. Имеются техники для анализа, в полной ли мере те или иные требования характеризуют функцию. Они позволяют найти неучтённые пограничные случаи, либо убедиться в их отсутствии. 

На первый взгляд, эти преимущества имеют значения только в очень нишевых областях, где используется формальная верификация кода. Однако даже если не заниматься формальной верификацией, само принципиальное понимание как формулировать и доказывать утверждения о программах, позволяет выработать достоверную ментальную модель — неформальный способ думать о программах, принципиально необходимый для написания корректных-по-построению программ. Именно в этом состоит главное практическое преимущество “математической фундированности” чисто-функциональных языков. Условия корректности редко выписывают явно вовсе не из-за лени, а потому, что их всё равно едва ли кто-нибудь читать до первого катастрофического сбоя. Совсем другое дело — хорошо структурированный, литературно написанный и очевидно корректный-по-построению код. Будучи укомплектован тестами, демонстрирующими типовое использование и покрывающими пограничные случаи, такой код — лучшая спецификация и лучшая документация самому себе. Только так можно гарантировать отсутствие расхождение между документацией, спецификацией и реализацией.

Несмотря на все эти преимущества, чисто-функциональные языки имеют и ограничения. Некоторые прикладные задачи, например создание интерактивных приложений и распределённых систем, не сводятся напрямую к преобразованию данных. Чтобы заниматься такими задачами на чисто-функциональных языках, приходится прибегать к использованию замысловатой машинерии, позволяющей окольными путями описывать манипуляции объектами на языках, лишенных возможности оперировать объектами напрямую.

Для решения именно таких задач спроектированы современные мультипарадигменные языки, такие как Kotlin, Rust и Scala, позволяющие оперировать напрямую не только данными, но и объектами. Но как распространить на них вышеописанные преимущества функциональных языков?

Внутри каждого современного мультипарадигменного языка сидит гораздо более простой чисто-функциональный язык, функциональное ядро языка. Мы возьмём функциональное ядро языка программирования Kotlin и шаг за шагом контроллируемо добавим в него императивные элементы, не теряя возможости строго описывать свойства программ. Начав с надёжного чисто-функционального фундаменты мы реконструием мультепарадигменный язык и “переизобретём”, как думать об объектах, эффектах и взаимодействующих процессах понятным и непротиворечивым образом. Даже если вы не намереваетесь заниматься формальной верификацией и вообще когда-либо пользоваться таким языком программирования, понимание его устройства поможет лучше понять многие моменты, касающиеся параллелизации, out-of-order execution, а также многие тонкости, постоянно возникающие в многопоточном программировании.

§ Pure Kotlin
-------------

(Для понимания нижеследущющего раздела желательно знакомство с языком программирования Котлин. Среди необщеизвестных элементов языка, которыми я буду активно пользоваться — `data classes` и `sealed abstract classes`, [при помощи которых можно описывать произвольные обобщённые алгебраические данных](https://docs.scala-lang.org/scala3/book/types-adts-gadts.html), `extension methods` и `extension properties`. Желательно также иметь общие представления о `companion objects` и `typeclasses`.)

Сперва определим Pure Kotlin — строго-функциональное ядро Kotlin'а, где все функции представляют из себя чистые функции, а все аргументы, параметры, и локальные переменные представляют из себя данные. В частности:
* исключается использование команд, даже таких как `return`, `throw`, `break` и `continue`; 
* внутри классов и объектов-компаньонов запрещаются изменяемые поля, в результате чего все типы данных становятся рекурсивно иммутабельными (hereditarliy immutable);
* равенство значений не может быть переопределено программистом, а выводится автоматически — покомпонентно, как для data classes;
* не существует никакого технического способа проверки равенства “адресов объектов в памяти“, и никаких механизмов runtime-интроспекции.

Мы можем разрешить использование локальных переменных `var` и циклов `while` и `repeat/while`, т.к. они могут быть сведены к рекурсии. Отметим, что и локальные определения `val x = expr` тоже могут быть сведены к применению и абстракций функций.

Для лучшего соответствия принятым в математике обозначениям, мы также будем
* использовать тип `Int` для обозначения потенциально неограниченно больших по модулю целых чисел, с реализацией как в Python3;
* интерпретировать бинарные операторы на числоподобных типах не как методы первого операнда, а как поля соответствующего объекта-компаньона/тайпкласса, использовать скобки для превращения бинарных операторов в функции и одинарные шевроны для превращения функций (бинарных или vararg) в бинарные операторы: `2 + 3 = (+)(2, 3) = 2 ‹Nat.plus› 3`;
* использовать `¬` в качестве оператора отрицания, в том числе в `¬in`, а также `a ≠ b` в качестве оператора различия;
* использовать одинарное равенство `a = b` вместо двойного в качестве оператора равенства;
* использовать оператор присвоения `val a := expr` вместо одинарного равенства в качестве оператора присвоения;
* показывать юникодную стрелки `{x ↦ x + 1}` вместо диграфа `->` в замыканиях и when-блоках;
* показывать оператор умножения как `·`;
* показывать отбитый пробелами с обеих сторон правый треугольник `x ▸ f` вместо `x.let f` в качестве оператора применения функции налево `x ▸ f := f(x)`;
* показывать вместо точки перед именем метода (но не поля!) правый треугольник;
* интерпретировать индентированные в точности на два пробела блоки, как будто они заключены в фигурные скобки:
```kotlin
files ▸filter
  it.size > 0 &&
  it.type = "image/png"
▸map { it.name }
```

Мы также предлагаем ввести `codata classes`:
```kotlin
codata class Seq<T>(val head : T)
  fun next() : Seq<T>

foo fib(prev : Int := 1, head : Int := 1) := Seq<T>(head)
  fun next() := fib(head, head + prev) 
```

И typeclasses:
```kotlin
data class <T>.Monoid(operator val ‹compose› : (vararg xs : T)-> T)
  val unit := compose() // unit is the nullary composition
  contracts {
    unit ‹compose› x = x
    x ‹compose› unit = x
    (x ‹compose› y) ‹compose› z = x ‹compose› (y ‹compose› z)
    
    compose(x, xs) = x ‹compose› compose(xs)
  }

// А теперь мы можем вот так:

fun<T : Monoid> square(x : T)
  x ‹T.compose› x

// И так:

fun<T : Monoid(`∘`)> square(x : T)
  x ∘ x
```

Pure Kotlin может быть расширен индуктивными типами, чекером тотальности и зависимыми типами.

§ Stratified Kotlin
-------------------

(Для понимания дальнейших разделов важно разобраться с двумя подсистемами Kotlin'а: `сontext receivers` + `type-safe builders` и `coroutines`/`suspensions` + `structured concurrency`.)

Stratified Kotlin — расширение Pure Kotlin, в котором мы допускаем использование команд и существование псевдовыражений. Для того, чтобы команду всегда можно было отличить от метода, её название должно начинаться с восклицательного знака: `!rand`, `!trace(msg)`, `!return`, `!throw`, `!break`. Исключая такие команды как `!rand` (многоразовые и коммутирующие с т.з. эффектов — такие команды называются **псевдозначениями**), в одной инструкции может быть использована не более чем одна команда:
```kotlin
!print( !delete("*.tmp") · !delete("*.*~") )    // так нельзя

val a := !rand + 2 · !rand                      // так можно
!print( !rand +  !rand )                        // так можно
```

Команды, не возвращающие значения (возвращающие `Unit` или `Nothing`). В частности нельзя опустить фигруные скобки вокруг `!return` или `!break` в
```kotlin
if (a = null) {return null}
a.first ?: {throw SomeException()}
```

Возвращающие `Nothing` команды (например `!return`) называются финальными — весь код, следующий за ними в их ветке выполнения был бы unreachable, поэтому они обязаны быть последними в своей ветке выполнения.

Исключая сводящиеся `if`-ам команды структурированных локальных переходов (`!return`, `!continue`, `!break`), команды можно использовать только в методах-расширениях и функциях контекст-ресиверах:
```kotlin
fun Tty.!foo() {
  val a := !ask<Int>("Please, enter an integer")
  val b := !ask<Int>("Please, enter another one")
  !print("Product of entered numbers is ${a + b}")
}
```

Тут `Tty` — интерфейс, сигнатура которого определяет набор доступных команд, их типы и поведение.

§ Интерфейсы и Объекты 
----------------------

Интерфейсы, доступные в Pure Kotlin переименуем в `data interface`, а ключевое слово `interface` будем использовать для типизации **объектов**. Многократно упоминавшиеся команды `!trace` и `!rand` принадлежат следующим интерфейсам:

```kotlin
interface Log
  fun trace(msg : String)

interface RandGen
  val rand: Int
```

Ключевое слово `fun` используется для задания команд, для которых порядок вызова важен, в то время как `val` используется для **псевдозначений** — команд, которые можно параллелизовывать. Выше уже упоминался хрестоматийный пример объекта — изменяемая (мутабельная) переменная. На Котлине её интерфейс можно было бы описать так:
```kotlin
interface Variable<T>
  val get : T
  fun set(v : T)
```

Другой христоматийный пример — телетайповый интерфейс взаимодействия с пользователем:
```kotlin
interface Tty
  fun print(msg : String)
  fun ask<T : Promptable>(prompt : String) : T
```

Каждое использование любой команды как бы “поглощает” объект целиком, и заменяет его новым, причём новый может вообще говоря иметь другой интерфейс. Если команда меняет интерфейс объекта, относительно которого вызвана, будем обозначать это в её сигнатуре специальной аннотацией `nextState<NextInterface>`:
```kotlin
interface OutputStream {
  fun append(s : String)
  fun close() nextState<Nothing>
}
```

Смена состояния на `Nothing` гарантирует, что после вызова `!close` в той же ветви исполнения будут недоступны команды `!close` и `!append`.

Механизм `nextState<Nothing>` позволяет описать один из важнейших типов объектов — “продолжения” (single-shot continuations):
```
fun interface Suspension<X, Y>
  fun resume(x : X) : Y nextState<Nothing>

// Suspension<X, Y> мы будем идентифицировать с `(X) ⊸ Y`

fun interface Continuation<T>
  fun resume(t : T) : Nothing

// возвращаемый тип Nothing автоматически означает и nextState<Nothing>

```
(Объяснение конструкции fun interface: https://kotlinlang.org/docs/fun-interfaces.html)

С использованием `nextState` у объекта больше нет постоянного набора методов — вместо этого у него имеется жизненный цикл, представляющий из себя конечный автомат состояний, и набор и сигнатуры доступных команд зависят от текущего состояния объекта. Котлин уже обладает механизмом smart casts, в результате которого тип переменной может сужаться по ходу выполнения программы — поддержка `nextState` требует расширения этого механизма.

Сигнатуры отдельных команд мы будем записывать вот так:
```
Variable<T>::get : (Variable<T>.() ⊸ T)*
Variable<T>::set : Variable<T>.(T) ⊸ (Unit nextState<Variable<T>>)

OutputStream::append : OutputStream.(String) ⊸ (Unit nextState<OutputStream>)
OutputStream::close : OutputStream.() ⊸ (Unit nextState<Nothing>)
```

Для исчерпывающего описания интерфейсов необходимо обеспечить в Stratified Kotlin поддержку зависимых типов. В зависимо-типизированных языках параметрами типов могут являться значения, например `List<T, size : Nat>`:
```kotlin
interface RandGen
  fun generateRandomPermutation(size : Nat) : List<Nat, size>
```

Для знатоков теории категорий отмечу что интерфейсы соответствуют свободно-порождённым зависимым комонадам (расширениям Кана).


§ Описание свойств объектов
---------------------------

Как уже было сказано в самом начале, понятие равенства в мире объектов расщипляется на две модальности — равенство эффектов и равенство результатов, которые мы будем обозначать через =e= и =r= соответственно.

Используя равенство эффектов мы можем указать важнейшее свойство команды `!rand` — отсутствие побочных эффектов:
```kotlin
interface RandGen {
  val !rand: Int
  
  contracts {
    {!rand} =e= {}
  }
}
```

Равенство результатов вообще говоря нерефлексивное, например `!rand =r= !rand` **не**
выполняется. Оператор `!foo : X ⊸ Y` называется детерминированным в точности, если
для него выполняется рефлексивность равенства результатов, т. е.
будучи вызван с одинаковым аргументом он всякий раз выдаёт одинаковые результат:
`a = b` влечёт `!foo(a) =r= !foo(b)`.

Также обратим внимание, что равенство результатов не влечёт равенства эффектов:
с точки зрения результатов любые два запроса, не возвращающие результатов, равны, но с точки зрения
эффектов `!trace("Hello")` и `!trace("Goodbye")` очевидно различаются.

Равенство эффектов напротив рефлексивное, но не влечёт равенства результатов. Равенство эффектов
может быть использована для выражения независимости (параллелизуемости) запросов. Мы можем, например,
постулировать, что запись в независимые потоки вывода (например, `!print` и `!trace`) коммутирует:
```kotlin
{!print(x); !trace(y)} =e= {!trace(y); !print(x)}
```

Информация о коммутировании тех или иных вызовов открывает богатые возможности для оптимизирующей
компиляции: компилятор, если это способно повысить производительность, может переставлять вызовы местами или даже вовсе параллелизовать их.

Приведём описание интерфейса `мутабельная переменная` с контрактами, в полной мере определяющими её поведение:

```kotlin
interface Variable<T>
  val get : T?
  fun set(v : T)
   
  contracts {
    !get =r= !get
    {!get} =e= {}

    {!set(x1); !set(x2)} =e= {!set(x2)}     
    {!set(x); !get} =r= x
```

Обратите внимание, что из контрактов и сигнатуры прямо следует, что `!get` может возвращать `null` только до первого вызова `!set`, но не очевидно, что он обязан выдавать именно `null` до первого вызова `!set`. Однако легко показать, что это единственное возможное поведение, если в качестве параметра `T` подставить `Nothing`, а из параметричности следует что при использовании любого другого типа поведение должно оставаться таким же.

Для знатоков теории категорий отмечу что контракты такого рода называются string diagrams, а интерфейсы, снабженные такими контрактами соответствуют конечно-представленным (вообще говоря, индуктивно-представленным) зависимым комонадам.

Для интерфейса, исчерпывающе заданого контрактами, можно автоматически сгенерировать монаду Дейкстры (https://arxiv.org/abs/1903.01237), предоставляющую удобный инструмент для формальной верификации программ.

<p align="center">* * *</p>

Некоторые объекты имеют методы, возвращающие не только значения, но и объекты. Это в частности resources, имеющие методы, позволяющие в дополнение к самому объекту сгенерировать дополнительные views с теми или иными capabilities, например
* `SharableMutableVariable`, к которой можно создать read-only reference или mutable reference;
* `Queue`, к которой можно создать множество каналов принимающих сообщения, и на которую можно подписать множество worker'ов;
* `Database`, к которой можно создать множество database connections с разными правами, в частности правом посылать в базу данный апдейты и правом подписываться на queries.

Поведение таких объектов описывается в терминах actor model/join calculus, а требования к ним описываются в терминах присущего join calculus понятия eventual consistency.

Другой сорт объектов, возвращающих объекты — factories, методы которых возвращают свеже-порождённые подобъекты, например
*  `Heap`, внутри которого можно создавать `SharableMutableVariables`;
*  `CoroutineContext`, внутри которого можно запускать `Worker`ов.
 
Контракты таких объектов требуют описание отношения отдельности подобъектов в терминах partial commutative monoids, и порождают не монаду Дейкстры, а более богатый математический объект, внутренним языком оторого является weakest precondition-based concurrent separation logic (IRIS).

<p align="center">* * *</p>

Для двух объектов, не являющихся подобъектом одного, тем не менее тоже можно дать определение независимости и изолированности. Объекты obj1 и obj2 называют независимыми вызовы методов obj1 и методов obj2 коммутируют между собой. Независимость объектов имплицирует отсутствие коммуникации между ними, но не означает детерминированности.

Изолированным называется объект, независимый от любых других объектов. Для `RandGen` и `Log`* это свойство постулируется, для детерминистски работающих мутабельных объектов, не замыкающих в себе других объектов, оно выполняется по построению. 

\* Мы постулируем, что считывание из собственных логов невозможно в рантайме ни прямо, ни опосредованно, иначе логи можно было бы использовать как хранилище информации.


§ Корутины и Продолжения 
------------------------

Выше мы говорили, что аргументами функций в Pure и Stratified Kotlin могут быть только значения, но не объекты.
В Stratified Kotlin мы добавим ещё и coroutines также известные как “suspendable functions”. Корутины могут принимать в качестве аргументов приведённые выше продолжения и подвешенные корутины (suspensions).

Всякую функцию `performSomeCalculation(x : X) : Y` мы можем превратить в корутину

```kotlin
suspend fun performSomeCalculationCPS(x : X, cont : Continuation<Y>)
  val result = performSomeCalculation(x)
  !cont(result)
```

Важно, что `cont` в каждой ветви выполнения можно запустить не более одного раза, и необходимо запустить не менее одного раза. В общем, в каждой ветви выполнения cont необходимо запустить ровно один раз. Причём её тип `Nothing` указывает на то, что все инструкции, следующие ниже её никогда не будет запущены (unreachable). Отметим, что команды `!break`, `!continue`, `!return` и `!throw` тоже имеют тип `Nothing` и таким образом всегда являются финальными командами своей ветви выполнения.

Второй отличительной особенностью корутин является то, что внутри корутины можно приостановить её выполнение и передать продолжение в качестве аргумента в другую корутину:
```kotlin
context(Log)
suspend fun useThatCalculation(x : X) : Y
  !trace("Executing foo.....")
  suspendCoroutine { cont ↦
    !performSomeCalculationCPS(x, cont)
  }
  !trace("After suspending.....")
```

Прежде мы только описывали объекты, но никогда не создавали их. Операция `suspendCoroutine {obj -> code}` “создаёт” объект `obj`. Мы можем обобщить эту операцию для создания объектов произвольного интерфейса. Правда, для этого нам понадобится аналог when с паттерн-матчингом.

```kotlin
interface S1
  foo(x : X) : Y nextState<S2>
  bar(a : A) : B nextstate<S2>
  ...

suspend fun zee(f : S1.(T) ⊸ R, t : T) : S {
  suspend.f(t) {
    foo(x : X) ↦ {cont : (S2.(Y) ⊸ R) ↦ 
      // something consuming cont and returning S
    }
    bar(a : A) ↦ {cont : (S2.(B) ⊸ R) ↦ 
      // something consuming cont and returning S
    }
    return(r : R) ↦ {
      // something returning S
    }
  }
}
```

В частности мы можем реализовать поддержку переменных, исключений и генераторов:
```kotlin
suspend fun<T, R, vararg Xs> withVar(f : Variable<T>.(*Xs) ⊸ R, v : T? := null) : R {
  suspend.f {
    val get := v
    
    set(v : Int) ↦ {
      withVar(it, v)
    } 
    
    return(r : R) ↦ r
}
```

```kotlin
interface Throws<E>
  throw(e : E) : Nothing

suspend fun<E, R> try(f : Throws<E>.() ⊸ R, handler : E -> R) : R {
  suspend.f {
    throw(e : R) ↦ handler(e)
    return(r : R) ↦ r  
  }
}
```

```kotlin
interface Generator<T>
  yield(g : T)

suspend fun<R> sum(generator : Generator<Int>.() ⊸ Unit, accumulator : Int := 0) {
  suspendInto(generator) {
    yield(v) ↦ {it : (State.(RetType) ⊸ R) ↦
      sum(it, v + accumulator)
    }
    return ↦ accumulator
  }
}
```

Когда мы определяем корутину, не замыкая внутрь объектов (значения и псевдозначения замыкать можно), сама корутина представляет из себя псевдозначение:
```kotlin
::performSomeCalculationCPS : ( (x : X, cont : (Y) ⊸ Nothing) ⊸ Nothing )*
::useThatCalculation : (Log.(X) ⊸ Y)*
```

Можно создать анонимную корутину, и целиком передать внутрь корутины объекты (ownership transfer), которые в этом случае должны быть там истрачены или тем или иным способом переданы дальше — в этом случае корутина будет иметь тип вида `(*Xs) ⊸ Y`. 

**TODO: Описать взаимодействие со Structured concurrency**

Мы познакомились со всеми важнейшими в программировании категориями объектов:
* generators/services;
* suspensions/continuations;
* workers/actors;
* factories;
* resources.

§ Объекты и линейная логика
---------------------------

В 1987 году J.-Y. Girard разработал обобщение одновременно классической и конструктивной логики высказываний, называемое линейной логикой. Ниже мы покажем, что все операции линейной логики могут быть определены на интерфейсах объектов, и соответствуют правилам линейной логики.

Дизьюнкции:
```kotlin
// Consumer-controlled disjunction:
interface Foo & Bar
  fun !foo() nextState<Foo>
  fun !bar() nestState<Bar>

// Server-controlled disjunction:
interface Foo ⊕ Bar
  val which : Bool
  fun !get() nextState<if(this.which) Foo else Bar>
```

Коньюнкции: **(TBD, в терминах корутин)**

Экспоненты: **(TBD, в терминах фабрик)**

§ Adjoint-логика
----------------

Stratified Kotlin оперирует как значениями, так и объектами. Выше мы рассказали, что для рассуждения о значениях используется исчисление предикатов, и убедились, что для рассуждения об объектах можно использовать линейную логику. Чтобы рассуждать о программах на Stratified Kotlin в целом, нам понадобится исчисление, сочетающее в себе линейную логику и исчисление предикатов. Такое исчисление недавно ввели Frank Pfenning et al. под названием adjoint logic/adjoint type theory. Мы приведём ссылки на основопологающие статьи по этой тематике **(TODO)**, но отметим что adjoint type theory далека от своей окончательной формы и является предметом активных научных исследований, которыми в частности занимается и автор этого текста.
Данный текст — вклад в разработку adjoint type theory со стороны практики программирования.

**TODO:** Описать практическую сторону сопряженных модальных операторов, позволяющих выражать линейную импликацию через (на выбор) монады или комонады. Описать практическое применение — обратную CPS-translation, при помощи которой императивный quicksort может быть повышен до “чистой функции“, благодаря тому что вся используемая внутри мутабельность и эффекты инкапсюлированы (“никак не проявляются наружу”).

* * *

Дополнительные главы:
* Eventual consistency изолированных объектов: как такое возможно? — Квантовая спутанность
* Prolog с объектами? — Functional logic programming + objects = quantum computations